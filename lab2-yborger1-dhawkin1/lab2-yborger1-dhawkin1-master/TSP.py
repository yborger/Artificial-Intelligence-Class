########################################
# CS63: Artificial Intelligence, Lab 2
# Fall 2022, Swarthmore College
########################################

import json
from random import shuffle, randrange
from itertools import combinations
try:
    import matplotlib
    matplotlib.use('Agg')#don't try to create a display window
    from matplotlib import pyplot
    _mpl_available = True
except:
    _mpl_available = False

from Tour import Tour

class TSP:
    """Represents a traveling salesperson problem in two dimensional
    Eculidean space.

    Local search candidates are Tour objects that specify an ordering over
    cities. Neighbors are generated by moving one city to a different spot
    in the ordering. The cost of a tour is the Euclidean distance traveled.

    Local search functions should call the following methods:
    random_candidate() to get an initial state
    best_neighbor() to get a best neighbor state
    random_neighbor() to get a random neighbor state
    cost(tour) to determine the total distance covered by a tour
    """
    def __init__(self, filename):
        """
        Parameters
        filename: json file with a single dict mapping city names to
                [latitude, longitude] pairs.
        Class variables
        locations: a dictionary keyed on cities, where values are a list 
        of latitute and longitude
        """
        with open(filename) as f:
            self.locations = json.load(f)

    def distance(self, city1, city2):
        """Euclidian distance in (lat, long) space."""
        lat1,lon1 = self.locations[city1]
        lat2,lon2 = self.locations[city2]
        return ((lat1 - lat2)**2 + (lon1 - lon2)**2)**.5

    def cost(self, tour):
        """Sum of Euclidian distances between adjacent cities in a tour.
        NOTE: This takes linear time. When possible, you should avoid
        calling cost() repeatedly on the same tour. Instead, save the
        value in a local variable and re-use it."""
        c = 0
        for city1, city2 in zip(tour, tour[1:]):
            c += self.distance(city1, city2)
        c += self.distance(tour[-1], tour[0])
        return c

    def random_candidate(self):
        """Generates a random ordering over locations."""
        new_tour = list(self.locations.keys())
        shuffle(new_tour)
        return Tour(new_tour)

    def plot(self, tour, filename):
        """Outputs a matplotlib plot of a tour to the specified filename."""
        assert _mpl_available, "matplotlib.pyplot didn't import correctly"
        longitudes = [self.locations[city][1] for city in tour] +\
                        [self.locations[tour[0]][1]]
        latitudes = [self.locations[city][0] for city in tour] +\
                        [self.locations[tour[0]][0]]
        pyplot.plot(longitudes, latitudes, marker="o")
        pyplot.savefig(filename)

    def _all_neighbors(self, tour):
        """Returns an iterable of all adjacent tours.  Adjacent tours are
        those where one city has been moved to a new index, but all
        others are in the same order.
        Returns: list of tours.
        """
        # moves represents all the different ways to swap between
        # 2 indices in the tour
        moves = combinations(range(len(tour)), 2)
        neighbors = []
        for move in moves:
            neighbors.append(tour.move_city(move[0], move[1]))
        return neighbors

    def best_neighbor(self, tour):
        """Returns the best adjacent tour and its cost.
        Adjacent tours are those where one city has been moved to a new
        index, but all others are in the same order.
        Returns: best_tour, best_cost

        NOTE: you should use _all_neighbors as a helper to implement this.
        """
        best_tour = None
        best_cost = float("inf")
        allNeighbors = self._all_neighbors(tour)
        for item in allNeighbors: 
            curr_cost = self.cost(item)
            if curr_cost < best_cost:
                best_tour = item
                best_cost = curr_cost

        return best_tour, best_cost



    def random_neighbor(self, tour):
        """Returns a randomly selected adjacent tour and its cost.
        Adjacent tours are those where one city has been moved to a new
        index, but all others are in the same order.
        Returns: tour, cost

        NOTE: you should NOT need to call _all_neighbors() to implement
        this. It can be done much more efficiently!"""
        
        first_swap = randrange(len(tour))
        second_swap = randrange(len(tour))
        while first_swap == second_swap:
            second_swap = randrange(len(tour))
        newTour = tour.move_city(first_swap, second_swap)
        newCost = self.cost(newTour)

        return newTour, newCost





if __name__ == '__main__':
    # create a new traveling salesperson problem based on cities in US
    problem = TSP("coordinates/South_Africa_10.json")

    # each problem maintains a dictionary called locations
    # the keys of locations are city names
    print("\nCities in this problem")
    cities = list(problem.locations.keys())
    print(cities)

    # create a tour from the locations, calculate the cost, and plot it
    tour = problem.random_candidate()
    neighbor, cost = problem.best_neighbor(tour)
    print("\nRandom tour for this problem\n", tour)
    print(neighbor, cost)
    cost = problem.cost(tour)
    print("\nCost for tour:", cost)
    problem.plot(tour, "tour")
